 
\documentclass[10pt]{article}

\usepackage[slovak]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}

\usepackage{times}


\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
 
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
 
\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{lemma}[2][Lemma]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{exercise}[2][Exercise]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{reflection}[2][Reflection]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{proposition}[2][Proposition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{corollary}[2][Corollary]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
 
\begin{document}
 
% --------------------------------------------------------------
%                         Start here
% --------------------------------------------------------------
 
%\renewcommand{\qedsymbol}{\filledbox}
 
\title{TIN - Domáca úloha č. 2}%replace X with the appropriate number
\author{Roman Dobiáš - xdobia11@stud.fit.vutbr.cz}
 
\maketitle

\section*{Úloha č.1}
Podľa definície 4.29 (opora, str. 97) je Dyckov jazyk na jednou dvojicou [] generovaný 
gramatikou s nasledujúcimi pravidlami, ktorú označme $G_D$:
\begin{align}
    S \to [ S ] | SS | \epsilon
\end{align}
Pre túto gramatiku zjavne platí, že každá postupnosť derivácii vedie ku terminálnemu reťazcu.

\subsection*{Čásť A}
V tejto časti ukážeme, že každý neprázdny reťazec $w \in L$ je možné vyjadriť v tvare $w = [u]v$,
kde $u,v \in L$.

Uvažujme neprázdny reťazec $w \in L$. Uvažujme prvú deriváciu štartujúceho nonterminálu $S$ v
gramatike $G_D$. Potom podľa definície gramatiky $G_D$ sú 3 možnosti, ktoré pravidlo mohlo byť
použité v prvej derivácii pri generovaní reťazca $w$:
\begin{enumerate}
    \item Pravidlo $S \to \epsilon$\\
        Potom $S \Rightarrow \epsilon$, teda $w = \epsilon$, čo je v spore s predpokladom, že
        $w$ je neprázdny reťazec. Pravidlo teda nemôže byť použité v prvej derivácii.
    \item Pravidlo $S \to [S]$\\
        Potom $S \Rightarrow [S] \Rightarrow^+ w$. Potom je reťazec $w$ nutne konkatenáciou
        tvaru $[u]v$, kde $u \in L \land v = \epsilon \land \epsilon \in L$, pretože S je počiatočný nonterminál gramatiky $G_D$, teda derivuje
        slovo $u \in L$. Zároveň zjavne platí, že $|w| =  2+|u|$ a $\#_[(w) = \#_[(u) + 1$. 
    \item Pravidlo $S \to SS$\\
        Vieme, že $w$ je neprázdne. V gramatike $G_D$ obsahuje len jedno pravidlo terminálne symboly,
        preto zjavne pravidlo $S \to [S]$ musí byť použité aspoň raz v postupnosti derivácii vetnej
        formy $SS$. Nutne teda platí, že z vetnej formy $SS$ deriváciami získame vetnú formu $S^N$.
        Zjavne aspoň jedno $S$ musí byť prepísané pravidlom $S \to [S]$. Zaujíma nás ten najľavejší
        prepísaný nonterminál $S$. Potom vzniknutá vetná forma má tvar $[S]S^N$. Zjavne platí, že
        $S \Rightarrow SS \Rightarrow SSS \Rightarrow^* S^N \Rightarrow v, v \in L$. Teda reťazec $w$
        je konkatenáciou $[u]v$, kde $S\Rightarrow^*u$ a $S \Rightarrow* S^N \Rightarrow* v$. Zjavne
        $|w| = 2 + |u|+|v|$.
\end{enumerate}
Ukázali sme teda, že každý neprázdny reťazec $w \in L$ je možné rozložiť na $[u]v$, kde $u,v \in L$.

\subsection*{Čásť B}
\begin{proof}
    Dokazujeme, že $\forall i \in \mathbb{N}_0: \forall w \in L: \#_[(w) = i \implies w \in L(G)$. V dokaze
    využívame gramatiku $G_D$, definovanú vyžšie (1). Pokiaľ derivácia nie je označená konkrétnou
    gramatikou, implicitne uvažujeme gramatiku $G$ zo zadania úlohy.\\

    Pre $i = 0$ tvrdenie platí, pretože epsilon je jediný reťazec v jazyku L taký, že $\#_[(\epsilon)
    = 0)$, zároveň platí, že $S \Rightarrow_{G_D} \epsilon$, teda $\epsilon \in L$ a tiež $S
    \Rightarrow_{G} \epsilon$, teda $\epsilon \in L(G)$. 

    Predpokladajme, že tvrdenie platí pre $j <  i$ a uvažujme platnosť tvrdenia $\forall w \in L: \#_[(w) = i \implies w \in L(G)$
    pre $i = j+1$.
    
    V a) sme ukázali, že pre $\forall w \in L: \exists u,v \in L: w = [u]v$. Teda isto platí, že
    $\forall w \in L \land \#_[(w) = i: \exists u,v \in L: w = [u]v$ a platí, že $\#_[(u) < i$ a zároveň
    $\#_[(v) < i$, pretože konkatenácia $[u]v$ pridáva reťazcu $w$ nutne o jeden symbol $[$ viac.
    Teda nutne $u,v \in L(G)$, pretože pre všetky $w\in L, \#_[(w) < i$ je veta už dokázaná. 
    Zároveň v gramatike G existuje pravidlo $S\to [S]S$, a kedže $u,v \in L(G)$, potom nutne existujú
    postupnosti derivácii $S\Rightarrow^* u$ a $S\Rightarrow^* v$.

    Dohromady v G existuje derivácia $S\Rightarrow [S]S \Rightarrow^* [u]S \Rightarrow^* [u]v$. Potom ale $w = [u]v$
    nutne patrí do L(G).

    Tvrdenie teda platí pre $i = j + 1$, kde pre $j$ je dokázané, teda platí pre $\forall i \in
    \mathbb{N}_0$. 
\end{proof}


\section*{Úloha č.2}
Dôkaz predvedieme pomocou Pumping Lemma pre bezkontextové jazyky. Dokážeme, že jazyk nie je
bezkontextový.

\begin{proof}
Nech $L$ je bezkontextový jazyk nad abecedou $\Sigma$. Potom existuje konštanta $k > 0$ taká, že platí:
    \begin{align}
        \forall z \in L \land |z| \geq k: \exists u,v,w,x,y \in \Sigma^*: z = uvwxy \land |vwx| \leq
        k \land \forall i \geq 0: uv^iwx^iy \in L
    \end{align}
Nech existuje konštanta $k > 0$ a reťazec $z=a^p$, kde $p$ je prvočíslo a zároveň $p > k$. Potom
podľa Pumping Lemma platí, že:
    \begin{align}
        \exists u,v,w,x,y \in \Sigma^*: z = uvwxy \land |vwx| \leq
        k \land \forall i \geq 0: uv^iwx^iy \in L
    \end{align}
    Uvažujme ľubovoľné konštanty $b, c,d \in \mathbb{N}_0$ také, že $a^ba^c \neq \epsilon$ a $u = a^b \land x =
    a^c \land w = a^d$ tak, že $|uwx| \leq k$ Zároveň zvoľme ľubovoľne $uy$ tak, nech platí, že $z = uvwxy$.
    Plati, že $uvwxy = ua^bwa^cy \in L$.

Uvažujme iteráciu pumpovania $i = 1+p$. 
    Potom $|uv^{i}wx^{i}y| = |uv^{1+p}wx^{1+p}y| = |ua^{b*(1+p)}wa^{c*(1+p)}y| = |ua^{b+bp}wa^{c+cp}y| = |ua^bwa^cy| +
    |a^{bp}|+|a^{cp}| = p + bp + cp = p(1+b+c)$. 
    Podľa predpokladu má platiť, že $uv^{i+p}wx^{i+p}y \in L$, avšak dĺžka tohoto reťazca je
    $p(1+b+c)$, čo je súčin prirodzených čísiel, teda nie je prvočíslom, teda $uv^{i+p}wx^{i+p}y \notin L$, čo je spor
    predpokladu. 
    Jazyk $\{a^p |$ p je prvočíslo $\}$ nie je bezkontextovy.
\end{proof}



\section*{Úloha č.3}
Najprv formálne definujme jazyky MP a jazyk Affine, medzi ktorými budeme definovať redukciu
$\sigma$. 
\begin{enumerate}
    \item MP = \{<M>\#<w> | TS M s kódom <M> zastaví na reťazci s kódom <w>\} $\cup \{0,1,\#\}^*$ 
    \item TuringAffine = \{<M>| jazyk TS s kódom <M> obsahuje aspoň 1 reťazec z jazyka Affine\} $\cup \{0,1\}^*$ 
\end{enumerate}
Nerozhodnuteľnosť problému \textit{TuringAffine} dokážeme zavedením redukcie z \textit{MP} na
\textit{TuringAffine}.

\subsection*{Idea redukcie}
Pre kód <M>\#<w> inštancie MP problému TS $M\sigma$ vygeneruje na výstupnú pásku TS Mx s kódom <Mx> taký, že:
\begin{enumerate}
    \item TS Mx vymaže svoju vstupnú pásku a skopíruje kód <M>\#<w>, ktorý má uložený v stavovom
        riadení na svoju pásku
    \item TS Mx skontroluje či kód <M> je korektný kód TS. To je možné, nakoľko jazyk kódovania TS
        je regularným jazykom. V prípade, že kód <M> nie je validným kódom TS, TS Mx odmietne. 
    \item TS Mx pomocou UTS simuluje <M> na kóde <w>
    \item Ak UTS cyklí, potom jazyk TS Mx je prázdny, teda neobsahuje reťazec z Affine (a
        <M>\#<w> nepatrí do MP.)
    \item Ak UTS zastaví a TS s kódom <M> prijal reťazec s kódom <w>, tak TS Mx prijime, inak odmietne.
\end{enumerate}

\subsection*{Realizácia redukcie}
\begin{itemize}
    \item Kód univerzálneho TS $M_{UTS}$, ktorý na svojej páske v tvare $\Delta <M>\#<w> \Delta$ simuluje
        prijatie reťazca s kódom $<w>$ TS s kódom $<M>$, je konštantný literál, ktorý je nezávislý
        na obsahu vstupnej pásky a je možné vytvoriť úplný TS, ktorý kód univerzálneho TS na pásku. 
    \item Kód TS $M_{valid}$, ktorý overuje, či kód TS <M> na páske je validne sformovaný, teda či <M> patrí do jazyka
        korektne zakódovaných TS, je literál TS simulujúceho beh konečného automatu. Tento kód je
        konštantný.
    \item Kód TS $M_{erase}$, ktorý vymaže svoju pásku, je konštantný literál. 
    \item Pre každý reťazec $<M>\#<w>$ sme schopný vytvoriť kód TS $M_{copy}$, ktorý po spustení vypíše na svoju
        pásku reťazec $<M>\#<w>$. 
    \item Nakoľko $M_{UTS}$, $M_{valid}$ i $M_{erase}$ sú konštantne dané TS, sme v stave vytvoriť
        kód TS $M_{merged}$, ktorý bude obsahovať tieto TS a pomocnú stavovú logiku, ktorá prijme ak $M_{UTS}$
        skončí.
    \item Nakoniec, sme v stave vytvoriť taký úplný TS $M\Sigma$, ktorý pred svoj vstup $<M>\#<w>$ vypíše na
        výstup kód TS <Mx>, ktorý bude obsahovať spojený TS $M_{merged}$, TS $M_copy$ a pomocné
        prechody medzi týmito TS.
    
    \item Redukcia je potom funkcia $\sigma: \{0,1,\#\}^* \to \{0,1\}^*$, ktorá je realizovaná úplnym
    TS $M\sigma$.
\end{itemize}

\subsection*{Korektnosť redukcie $\sigma$}
Skúmajme jazyk L(Mx):
\begin{enumerate}
    \item $L(Mx) = \emptyset \iff$ <M> nie je korektný kód TS alebo TS <M> na slove <w> cyklí 
    \item $L(Mx) = \Sigma^* \iff$ <M> je správne sformulovaný kód TS a TS s kódom <M> prijíma kód <w>
\end{enumerate}

Dokážeme, že redukcia je korektná.
\begin{enumerate}
    \item <M>\#<w> $\in MP \iff$ TS M je správne sformovaný a TS <M> príjme <w> $\iff L(Mx) =
        \Sigma^* \iff$ TS <Mx> taký, že jazyk L(Mx) obsahuje aspoň jeden reťazec z jazyka Affine
        $\iff$ <Mx> $\in$ TurringAffine
\end{enumerate}

Nakoniec je nutné ukázať, že pre každú kombináciu konštant $a_0$ a $a_1$ je jazyk Affine vždy
neprázdny, teda je možné nájsť aspoň jeden reťazec jazyka Affine. Ak by bol jazyk Affine prázdny,
potom by nebolo možné redukciou vyjadriť oba prípady rozhodovacieho problému MP a redukcia by teda
neexistovala. 

Avšak, pre ľubovoľné konštantny $a_0$ a $a_1$ vždy existuje reťazec, ktorý patrí do daného jazyka Affine.
Napríklad pre $w = 0^{a_1}$ vždy $w
\in Affine$, pretože platí $a_0 \times a_1 + a_1 \times 0 - a_1\times a_0 = 0$.

Dokázali sme teda, že existuje redukcia z MP, ktorý je nerozhodnuteľný, na problém TuringAffine.
TuringAffine je teda nutne nerozhodnuteľný.
\subsection*{Idea čiastočnej rozhodnuteľnosti}
Čiastočnú rozhodnuteľnosť je možné dokázať redukciou problému TuringAffine na iný rozhodovací
problém, ktorý je práve čiastočne rozhodnuteľný, napr. problém neprázdnosti jazyka TS (problém NEP). 
Problém NEP je čiastočne vyčísliteľný podľa tvrdenia zo skript, str. 129. 

Potom totiž platí vzťah $TurringAffine \leq NEP$ a podla vety $6.3.1$ (skripta, str. 128) platí, že
ak NEP je rekurzívne vyčísliteľný, potom aj TurringAffine je rekurzívne vyčísliteľný, teda čiastočne
rozhodnuteľný. 

Následne si ukážeme, akým spôsobom by bola prevedená redukcia $\sigma$.
Formálne sú rozhodovacie problémy nasledujúce:
\begin{enumerate}
    \item TuringAffine = \{<M>| jazyk TS s kódom <M> obsahuje aspoň 1 reťazec z jazyka Affine\} $\cup \{0,1\}^*$ 
    \item NEP = \{<M>| jazyk TS s kódom <M> obsahuje aspoň 1 (je neprázdny)\} $\cup \{0,1\}^*$ 
\end{enumerate}

Redukcia $\sigma: {0,1}^* \to {0,1}^*$, ktorá každej inštancii z jazyka TuringAffine priradí
inštanciu jazyka NEP, by bola realizovaná nasledujúco:
Úplný TS realizujúci redukciu $\sigma$ pre daný vstup má na svojom výstupe TS s kódom <Mx>, ktorý
realizuje nasledujúcu činnosť:
\begin{enumerate}
    \item TS Mx overí, či reťazec w na jeho vstupe patrí do jazyka Affine. Príslušnosť reťazca do
        jazyka Affine je realizovateľná pomocou TS - stačí spočítať počet symbolov 0 a 1 v reťazci
        w, previesť príslušné násobenie a odčítanie a porovnať výsledok voči nule. Konštanty
        a0 a a1 môže mať daný TS zakódované vo svojom stavovom riadení.
    \item Ak reťazec w nepatrí do jazyka Affine, potom TS Mx odmietne.
    \item Inak TS Mx posunie reťazec w, ktorý má zapísaný na páske, a skopíruje kód
        TS M <M>, čím na páske vznikne <M>\#w
    \item TS Mx overí, či TS s kódom <M> je korektne sformovaný TS. Ak nie odmietne.
    \item Napokon, TS Mx s pomocou UTS simuluje prijatie reťazca w TS s kódom <M>. Ak TS s kódom <M>
        odmietne reťazec w alebo cyklí, potom TS Mx odmietne, inak prijme.
\end{enumerate}
Skúmajme jazyk TS Mx:
\begin{enumerate}
    \item $L(Mx) = \emptyset \iff$ TS <M> nie je správne sformovaný alebo TS <M> je správne
        sformovaný, ale L(M) neobsahuje ani jeden reťazec z jazyka Affine.
    \item $L(Mx) \neq \emptyset \iff$ TS <M> je správne sformovaný a L(M) obsahuje aspoň jeden reťazec
        z jazyka Affine
\end{enumerate}

Zjavne platí, že TS <M> obsahuje reťazec z jazyka Affine $\iff$ TS <M> je správne sformovaný a L(M)
obsahuje aspoň jeden reťazec z jazyka Affine $\iff L(Mx) \neq \emptyset \iff$ TS s kódom <Mx> a
jazyk L(Mx) je neprázdny.

\section*{Úloha č.4}
Turingovú úplnosť programu \textit{RacionalC} dokážeme konštruktívne. Ukážeme, že každý TS je možné
zakódovať ako ekvivalentný program \textit{RacionalC}, a naopak, že každý program \textit{RacionalC}
je možné vytvoriť ekvivalentný TS.

Pred popisom jednotlivých prevodov je nutné uvedomiť si, akým spôsobom sú si TS a
\textit{RacionalC} podobné. \textit{RacionalC} pracuje s racionálnym číslom, pričom umožňuje toto číslo deliť a násobiť 2,
prípadne nastavovať jeho párnosť, či nepárnosť, a rovnako disponuje príkazmi pre zmenu toku programu
podľa párnosti. 
Efekt týchto operácii môžeme skúmať na binárnom kóde racionálneho čísla v registri x.
Zjavne platí, že operácie deleno / násobenie 2 posúvajú desatinnú čiarku v binárnej reprezentácii
čísla. Podobne operácia even / odd v skutočnosti len mení hodnotu bitu čísla x, ktorý leží tesne
pred desatinnou čiarkou. Nakoniec, príkaz if modulo v skutočnosti zisťuje aktuálnu hodnotu bitu
pred desatinnou čiarkou a podľa toho skáče v programe.

Ekvivalentné operácie ku spomenutým operáciam môžeme vidieť aj v TS. Uvažujme pásku automatu len nad
symbolmi 0 a 1. Potom pozíciu čítacej hlavy na páske
môžeme vnímať ako pozíciu desatinnej čiarky v čísle s kódom odpovedajúcemu páske.
Operácie násobenie a delenie je možné realizovať v TS ako posun čítajúcej hlavy.
Podobne, zápis symbolu pod čtecí hlavou je možné sémanticky vnímať ako operácie odd/even.
Nakoniec, samotné prechody TS realizujú podmienené vykonávanie v závislosti na hodnote symbolu pod
čtecí hlavou na páske.

Jednotlivé operácie je teda možné zakódovať ekvivalentne v TS aj v programe \textit{RacionalC}.

V následujúcej časti predstavený príkladný spôsob zakódovania spolu s ošetrením špeciálneho
chovania, akým je prepadnutie hlavy TS, či nekonečné rozširovanie reprezentácie racionálneho čísla
do oboch smerov v programe \textit{RacionalC}.

\subsection*{A - Prevod TS na RationalC}
Podľa zadania prevádzame deterministický TS s abecedou $\Sigma = {0,1}$ a páskovou abecedou 
$\Gamma = \Sigma \cup {\Delta}$. V prípade, že by pásková abeceda obsahovala ďalšie znaky, je možné 
TS previesť na TS s $\Gamma = \Sigma \cup {\Delta}$ pomocou zakódovania symbolov rozšírenej páskovej abecedy
ako postupností symbolov z $\Gamma$ (opora, str. TODO).

Prevod TS na RationalC sa skladá z nasledujúcich částí
\subsubsection*{Prevod vstupnej pásky TS na číslo $x_0$}
    Vstupná páska TS má tvar $\Delta w \Delta$, kde $w \in \Sigma$. Keďže vieme, že program
    $RacionalC$ má na vstupe celé číslo $x_0$ a naopak TS začína na pozícii $\Delta$, musíme
    pred prevodom reťazec $\Delta w \Delta$ reverzovať. 
    Následne je páska $\Delta w^R \Delta$ obsahujúca znaky $0,1,\Delta$ je prevedená nasledujúco:
    \begin{align*}
        &\Delta \implies 00 &  & \#  \implies 11 &
        &0 \implies 10 &  &1 \implies 11 
    \end{align*}
    Kódovanie sme rozšírili o špeciálny symbol $\#$, ktorý nie je súčasťou páskovej abecedy.
    Tento špeciálny symbol je nutný pre korektné dekovanie stavu, kedy TS prepadla hlava.

    Po prevedení symbolov w na takéto binárne kódovanie je výsledný reťazec interpretovaný ako
    binárne zakódované prirodzené číslo rozšírené o kód symbolu $\#$.

    Príklad w: $\Delta011\Delta$ sa po reverzácii na $\Delta110\Delta$ zobrazí na $00 11 10 10 00
    11$, teda na prirodzené číslo $931$. Vďaka kódu $00$ pre $\Delta$ obsahuje racionálne číslo nekonečno znakov
    reprezentujúcich $\Delta$ z prava aj z ľava pôvodonej pásky $w$, pretože dvojica 00 pridaná
    pred aj na koniec binárnej reprezentácie čísla nemení jeho význam.

    Nakoľko sme oproti reprezentácii pásky TS posunuli desatinnú čiarku pridaním oddelovača $\#$, je
    nutné na začiatku programu \textit{RacionalC} vykonať 2x príkaz $x \setminus = 2;$ aby sme posunuli čiarku na
    správne miesto.

\subsubsection*{Prevod jednotlivých pravidiel TS na príkazy jazyka \textit{RacionalC}}
    Jednotlivé stavy TS sú v \textit{RationalC} reprezentované sekvenciou príkazov. 
    Keďže jednotlivé symboly TS sú v RationalC reprezentované dvojicami bitov racionálneho čísla, potom posun hlavy je
    realizovaný 2x násobením alebo 2x delením, čo má za následok posun desatinnej čiarky o
    dvojicu bitov.

    Realizácia koncového stavu je nasledujúca:
    \begin{verbatim}
    q_f: return 1;
    \end{verbatim}

    Realizáciu nejakého nekoncového stavu $q$ z TS je možné vyjadriť nasledujúcim pseudo kódom:
    \begin{verbatim}
    q: 
    q_0:   Over či symbol je rovný 0. Ak nie skáč na q_1
    q_0+1: Vykonaj prechod definovaný pre d(q,0). 
    q_1:   Over či symbol je rovný 1. Ak nie skáč na q_D
    q_1+1: Vykonaj prechod definovaný pre d(q,1). 
    q_D:   Over či symbol je rovný Delta. Ak nie skáč na q_#
    q_D+1: Vykonaj prechod definovaný pre d(q,Delta). 
    q_#:   return 0 // pre # doslo k prepadnutiu hlavy
    \end{verbatim}

    Poznámka: ak pre daný stav nie je prechod pre daný symbol definovaný, potom je sekvencia
    "vykonaj prechod" nahradená jediným príkazom $return 0;$, ktorý odpovedá zastaveniu TS na
    nedefinovanom prechode.

    Symboly $q, q\_0$ a pod. označujú symbolicky číslo riadku, na ktorom začína daná sekvencia. 
    Realizáciu jednotlivých overení pre každý zakódovaný symbol $S$ z $\Gamma$ môžeme vyjadriť
    nasledujúcou sekvenciou príkazov, kde $X$ a $Y$ je kód symbolu z prekódovania vyššie (napr. $0 =
    10 \implies X = 1 \land Y = 0$).
    \begin{verbatim}
    // OVERENIE pre symbol S 
    q_S:   if x \% 2 == Y goto q_S+3    // zaciname na bite Y
    q_S+1: GOTO(q_next)                 // ak Y nesedi, skusime iny symbol 
    q_S+3: x /= 2                       // posun na bit X
    q_S+4: if x \% 2 == Y goto q_S+7 
    q_S+5: x *= 2       // ak nesedi ani X, vratime hlavu na Y
    q_S+6: GOTO(q_next) // nepodmienecny skok na overenie ďalšieho symbolu
    q_S+7: x *= 2       // ďalej následuje vykonanie prechodu pre symbol S
    \end{verbatim}
    Poznámka: Symbol \textbf{q\_next} je nasledujúci symbol páskovej abecedy z $\Gamma$. Pre
    $\Delta$ je to nakoniec $\#$.  
    Poznámka: Makro \textbf{GOTO(state)} sa expanduje na sekvenciu príkazov \texttt{if x \% 2 == 0 goto
    state; if x \% 2 == 0 goto state} 

    Sekvencia príkazov odpovedajúca vykonaniu prechodu je potom závislá na konkrétnom type prechodu.
    
    Pre \textbf{zápis symbolu} $x \in \Gamma$, ktorého kód je rovný $XY$ a prechod do stavu $p$ ide o
    nasledujúcu sekvenciu:
    \begin{verbatim}
    q_S_X:   WRITE(Y)
    q_S_X+1: x /= 2
    q_S_X+2: WRITE(X)
    q_S_X+3: x *= 2
    q_S+6:   GOTO(q_next)
    \end{verbatim}
    Poznámka: Makro \textbf{WRITE(Z)} sa expanduje pre $Z = 0$ na $x = even(x)$, pre $Z = 1$ na $x = odd(x)$ 

    \textbf{Posun hlavy} na páske smerom $Z = {L,R}$ a prechod na stav $s$:
    \begin{verbatim}
    q_S_X: SHIFT(Z) 
    q_S_X: SHIFT(Z)  
    q_S+6: GOTO(S) // skok na stav S
    \end{verbatim}
    Poznámka: Makro \textbf{SHIFT(Z)} sa expanduje pre $Z = R$ na $x \div = 2$, pre $Z = L$ na $x *= 2)$ 
    Poznámka: Invertovanie posunu na páske TS voči posunu desatinnej čiarky vzniklo reverzovaním reťazca $w$.

    Na začiatku program prevedie shift o 2 pozície do ľava, aby umiestnil destinnú čiarku pred
    symbol $\#$. Následne následuje vykonávanie sekvencie reprezentujúcej počiatočny stav TS.

    Týmto spôsobom sme teda ukázali, že každý stav z TS a jeho prechody sme schopný zakódovať
    ekvivalentne v príkazoch \textit{RationalC}. 
    Zároveň program v \textit{RationalC} korektne detekuje prepadnutie hlavy, zastavenie na
    nedefinovanom prechode pre daný stav (return 0) a konečne prijatie v stave $q_f$.


\subsection*{B - RationalC na TS}
TODO

Prirodzené číslo $x_0$ môžeme reprezentovať ako binárne kódovaný číslo. Na počiatku má teda páska
tvar $\Delta w^R \Delta$, kde $w$ je binárne zakódované prirodzené číslo $x_0$ a zároveň obsahuje TS sekvenciu
prechod do prava, ktoré posunú hlavu na tú pozíciu, ktorá v pôvodnom racionálnom čísle
predstavovala desatinnú čiarku. Desatinná čiarka simulovaného registra $x_0$ sa v TS nachádza vždy
za pozíciou hlavy.
Podobne ako pri prevode na program, aj tu je nutno užiť reverzáciu reťazca z dôvodu, že program má
pri štarte desatinnú čiarku na konci reťazca, kdežto TS na začiatku pásky.

\textbf{Príklad:}
Prirodzené číslo 29 má binárne zakódovanie 11101. Jeho reverzáciou získavame 10111 a dokopy
počiatočnu pásku $\Delta 11101 \Delta$. 
Zároveň pridáme do TS jeden extra počiatnočný stav, ktorý posunie hlavu do prava a prejde na
počiatočný stav programu.

\subsubsection*{Prevod programu na stavy}
Pred tým, než zadefinujeme prevod na TS, je nutné uvažovať na situáciami, ktoré musí TS korektne
ošetriť. Pôvodný program totiž pracuje s neobmedzeným racionálnym číslom, teda s páskou, ktorá
rastie do oboch strán. Naproti tomu, TS má pásku obmedzenú z ľava. Preto nutne bude TS pri posunutí
hlavy do ľava kontrolovať, či po prechode nemá pod hlavou blank. Ak áno, potom aktivuje TS, ktorý
skočí na ďalší blank do prava, vykoná shift do prava, skočí na blank v ľavo, zapíše 0 a pokračuje.

Podobne, pri skoku do ľava je nutné prepísať prípadný blank, ktorý sa po prechode môže vyskytnúť pod
hlavou na 0, zavedením pomocného stavu a dvojicou prechodou (posun hlavy a zápis 0).

Samotný prevod príkazov vykonáme nasledovne. Každý riadok s príkazom programu \textit{RationalC} je realizovaný ako jeden unikátny stav v TS.
Implicitne, po vykonaní každého príkazu (okrem if) následuje zmena stavu na stav, reprezentovaný
nasledujúcim riadkom v programe. V TS preto po vykonaní prechodu,  

Uvažujme nasledujúce ekvivalentné vyjadrenie:
\begin{enumerate}
    \item \textbf{return} 0 => abnormálne zastavenie TS (napr. pomocou prepadnutia hlavy)
    \item \textbf{return} 1 => prechod do koncového stavu $q_F$
    \item x = \textbf{odd}(x) => nepodminenený zápis 1 pod čtecí hlavou
    \item x = \textbf{even}(x) => nepodminenený zápis 1 pod čtecí hlavou
    \item x \textbf{*=} x => posun hlavy do ľava (reverzácia)
    \item x \textbf{$\setminus$=} x => posun hlavy do prava (reverzácia)
    \item if \textbf{x \%2} == b goto N => pre symbol B = {0,1} na páske preveď prechod do stavu na riadku N
\end{enumerate}

Z počiatočného stavu preto vykoná TS prechod s posunutím hlavy doprava realizuje príkaz $x *= 2$, doľava zas $x /= 2$. Príkaz odd /
even sú realizované ako zápis symbolu 1 / 0 pod hlavou.

Príkazy $x *= 2 / x /= 2$ sú prechody z aktuálneho stavu do stavu a posunutím hlavy,
príkazy even() či odd() zas zápisom symbolu pod hlavou na páske TS.
Príkaz return 1; predstavuje prechod pod ľubovoľným symbolom $\Sigma$ do koncového stavu TS,
príkaz return 0 zas spustenie podprogramu, ktorý bude nekonečne cykliť do prava.
Pre všetky stavy je pod symbolom $\Delta$ pridaný podprogram, ktorý skočí na prvý $\Delta$ na pravo od
hlavy, vyvolá shift right, skočí na prvý delta na ľavo a zapíše do neho symbol 0.
Týmto spôsobom je ošetrená situácia, kedy sa racionálne číslo delením rozšíruje smerom do ľava
(nulami), čo by spôsobilo prepadnutie hlavy v TS. 
Tak isto, pri násobení čísla tento podprogram korektne ošetrí rozšírenie binárneho kódovania o 0
zprava.

\end{document}
