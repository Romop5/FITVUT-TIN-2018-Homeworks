 
\documentclass[10pt]{article}

\usepackage[slovak]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}

\usepackage{times}


\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
 
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
 
\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{lemma}[2][Lemma]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{exercise}[2][Exercise]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{reflection}[2][Reflection]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{proposition}[2][Proposition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{corollary}[2][Corollary]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
 
\begin{document}
 
% --------------------------------------------------------------
%                         Start here
% --------------------------------------------------------------
 
%\renewcommand{\qedsymbol}{\filledbox}
 
\title{TIN - Domáca úloha č. 2}%replace X with the appropriate number
\author{Roman Dobiáš - xdobia11@stud.fit.vutbr.cz}
 
\maketitle

\section*{Úloha č.1}
Podľa definície 4.29 (opora, str. 97) je Dyckov jazyk na jednou dvojicou [] generovaný 
gramatikou s nasledujúcimi pravidlami, ktorú označme $G_D$:
\begin{align}
    S \to [ S ] | SS | \epsilon
\end{align}
Pre túto gramatiku zjavne platí, že každá postupnosť derivácii vedie ku terminálnemu reťazcu.

\subsection*{Čásť A}
V tejto časti ukážeme, že každý neprázdny reťazec $w \in L$ je možné vyjadriť v tvare $w = [u]v$,
kde $u,v \in L$.

Uvažujme neprázdny reťazec $w \in L$. Uvažujme prvú deriváciu štartujúceho nonterminálu $S$ v
gramatike $G_D$. Potom podľa definície gramatiky $G_D$ sú 3 možnosti, ktoré pravidlo mohlo byť
použité v prvej derivácii pri generovaní reťazca $w$:
\begin{enumerate}
    \item Pravidlo $S \to \epsilon$\\
        Potom $S \Rightarrow \epsilon$, teda $w = \epsilon$, čo je v spore s predpokladom, že
        $w$ je neprázdny reťazec. Pravidlo teda nemôže byť použité v prvej derivácii.
    \item Pravidlo $S \to [S]$\\
        Potom $S \Rightarrow [S] \Rightarrow^+ w$. Potom je reťazec $w$ nutne konkatenáciou
        tvaru $[u]v$, kde $u \in L \land v = \epsilon \land \epsilon \in L$, pretože S je počiatočný nonterminál gramatiky $G_D$, teda derivuje
        slovo $u \in L$. Zároveň zjavne platí, že $|w| =  2+|u|$ a $\#_[(w) = \#_[(u) + 1$. 
    \item Pravidlo $S \to SS$\\
        Vieme, že $w$ je neprázdne. V gramatike $G_D$ obsahuje len jedno pravidlo terminálne symboly,
        preto zjavne pravidlo $S \to [S]$ musí byť použité aspoň raz v postupnosti derivácii vetnej
        formy $SS$. Nutne teda platí, že z vetnej formy $SS$ deriváciami získame vetnú formu $S^N$.
        Zjavne aspoň jedno $S$ musí byť prepísané pravidlom $S \to [S]$. Zaujíma nás ten najľavejší
        prepísaný nonterminál $S$. Potom vzniknutá vetná forma má tvar $[S]S^N$. Zjavne platí, že
        $S \Rightarrow SS \Rightarrow SSS \Rightarrow^* S^N \Rightarrow v, v \in L$. Teda reťazec $w$
        je konkatenáciou $[u]v$, kde $S\Rightarrow^*u$ a $S \Rightarrow* S^N \Rightarrow* v$. Zjavne
        $|w| = 2 + |u|+|v|$.
\end{enumerate}
Ukázali sme teda, že každý neprázdny reťazec $w \in L$ je možné rozložiť na $[u]v$, kde $u,v \in L$.

\subsection*{Čásť B}
\begin{proof}
    Dokazujeme, že $\forall i \in \mathbb{N}_0: \forall w \in L: \#_[(w) = i \implies w \in L(G)$. V dokaze
    využívame gramatiku $G_D$, definovanú vyžšie (1). Pokiaľ derivácia nie je označená konkrétnou
    gramatikou, implicitne uvažujeme gramatiku $G$ zo zadania úlohy.\\

    Pre $i = 0$ tvrdenie platí, pretože epsilon je jediný reťazec v jazyku L taký, že $\#_[(\epsilon)
    = 0)$, zároveň platí, že $S \Rightarrow_{G_D} \epsilon$, teda $\epsilon \in L$ a tiež $S
    \Rightarrow_{G} \epsilon$, teda $\epsilon \in L(G)$. 

    Predpokladajme, že tvrdenie platí pre $j <  i$ a uvažujme platnosť tvrdenia $\forall w \in L: \#_[(w) = i \implies w \in L(G)$
    pre $i = j+1$.
    
    V a) sme ukázali, že pre $\forall w \in L: \exists u,v \in L: w = [u]v$. Teda isto platí, že
    $\forall w \in L \land \#_[(w) = i: \exists u,v \in L: w = [u]v$ a platí, že $\#_[(u) < i$ a zároveň
    $\#_[(v) < i$, pretože konkatenácia $[u]v$ pridáva reťazcu $w$ nutne o jeden symbol $[$ viac.
    Teda nutne $u,v \in L(G)$, pretože pre všetky $w\in L, \#_[(w) < i$ je veta už dokázaná. 
    Zároveň v gramatike G existuje pravidlo $S\to [S]S$, a kedže $u,v \in L(G)$, potom nutne existujú
    postupnosti derivácii $S\Rightarrow^* u$ a $S\Rightarrow^* v$.

    Dohromady v G existuje derivácia $S\Rightarrow [S]S \Rightarrow^* [u]S \Rightarrow^* [u]v$. Potom ale $w = [u]v$
    nutne patrí do L(G).

    Tvrdenie teda platí pre $i = j + 1$, kde pre $j$ je dokázané, teda platí pre $\forall i \in
    \mathbb{N}_0$. 
\end{proof}


\section*{Úloha č.2}
Dôkaz predvedieme pomocou Pumping Lemma pre bezkontextové jazyky. Dokážeme, že jazyk nie je
bezkontextový.

\begin{proof}
Nech $L$ je bezkontextový jazyk nad abecedou $\Sigma$. Potom existuje konštanta $k > 0$ taká, že platí:
    \begin{align}
        \forall z \in L \land |z| \geq k: \exists u,v,w,x,y \in \Sigma^*: z = uvwxy \land |vwx| \leq
        k \land \forall i \geq 0: uv^iwx^iy \in L
    \end{align}
Nech existuje konštanta $k > 0$ a reťazec $z=a^p$, kde $p$ je prvočíslo a zároveň $p > k$. Potom
podľa Pumping Lemma platí, že:
    \begin{align}
        \exists u,v,w,x,y \in \Sigma^*: z = uvwxy \land |vwx| \leq
        k \land \forall i \geq 0: uv^iwx^iy \in L
    \end{align}
    Uvažujme ľubovoľné konštanty $b, c,d \in \mathbb{N}_0$ také, že $a^ba^c \neq \epsilon$ a $u = a^b \land x =
    a^c \land w = a^d$ tak, že $|uwx| \leq k$ Zároveň zvoľme ľubovoľne $uy$ tak, nech platí, že $z = uvwxy$.
    Plati, že $uvwxy = ua^bwa^cy \in L$.

Uvažujme iteráciu pumpovania $i = 1+p$. 
    Potom $|uv^{i}wx^{i}y| = |uv^{1+p}wx^{1+p}y| = |ua^{b*(1+p)}wa^{c*(1+p)}y| = |ua^{b+bp}wa^{c+cp}y| = |ua^bwa^cy| +
    |a^{bp}|+|a^{cp}| = p + bp + cp = p(1+b+c)$. 
    Podľa predpokladu má platiť, že $uv^{i+p}wx^{i+p}y \in L$, avšak dĺžka tohoto reťazca je
    $p(1+b+c)$, čo je súčin prirodzených čísiel, teda nie je prvočíslom, teda $uv^{i+p}wx^{i+p}y \notin L$, čo je spor
    predpokladu. 
    Jazyk $\{a^p |$ p je prvočíslo $\}$ nie je bezkontextovy.
\end{proof}



\section*{Úloha č.3}
Najprv formálne definujme jazyky MP a jazyk Affine, medzi ktorými budeme definovať redukciu
$\sigma$. 
\begin{enumerate}
    \item MP = \{<M>\#<w> | TS M s kódom <M> zastaví na reťazci s kódom <w>\} $\cup \{0,1,\#\}^*$ 
    \item TuringAffine = \{<M>| jazyk TS s kódom <M> obsahuje aspoň 1 reťazec z jazyka Affine\} $\cup \{0,1\}^*$ 
\end{enumerate}
Nerozhodnuteľnosť problému \textit{TuringAffine} dokážeme zavedením redukcie z \textit{MP} na
\textit{TuringAffine}.

\subsection*{Idea redukcie}
Pre kód <M>\#<w> inštancie MP problému TS $M\sigma$ vygeneruje na výstupnú pásku TS Mx s kódom <Mx> taký, že:
\begin{enumerate}
    \item TS Mx vymaže svoju vstupnú pásku a skopíruje kód <M>\#<w>, ktorý má uložený v stavovom
        riadení na svoju pásku
    \item TS Mx skontroluje či kód <M> je korektný kód TS. To je možné, nakoľko jazyk kódovania TS
        je regularným jazykom. V prípade, že kód <M> nie je validným kódom TS, TS Mx odmietne. 
    \item TS Mx pomocou UTS simuluje <M> na kóde <w>
    \item Ak UTS cyklí, potom jazyk TS Mx je prázdny, teda neobsahuje reťazec z Affine (a
        <M>\#<w> nepatrí do MP.)
    \item Ak UTS zastaví a TS s kódom <M> prijal reťazec s kódom <w>, tak TS Mx prijime, inak odmietne.
\end{enumerate}

\subsection*{Realizácia redukcie}
\begin{itemize}
    \item Kód univerzálneho TS $M_{UTS}$, ktorý na svojej páske v tvare $\Delta <M>\#<w> \Delta$ simuluje
        prijatie reťazca s kódom $<w>$ TS s kódom $<M>$, je konštantný literál, ktorý je nezávislý
        na obsahu vstupnej pásky a je možné vytvoriť úplný TS, ktorý kód univerzálneho TS na pásku. 
    \item Kód TS $M_{valid}$, ktorý overuje, či kód TS <M> na páske je validne sformovaný, teda či <M> patrí do jazyka
        korektne zakódovaných TS, je literál TS simulujúceho beh konečného automatu. Tento kód je
        konštantný.
    \item Kód TS $M_{erase}$, ktorý vymaže svoju pásku, je konštantný literál. 
    \item Pre každý reťazec $<M>\#<w>$ sme schopný vytvoriť kód TS $M_{copy}$, ktorý po spustení vypíše na svoju
        pásku reťazec $<M>\#<w>$. 
    \item Nakoľko $M_{UTS}$, $M_{valid}$ i $M_{erase}$ sú konštantne dané TS, sme v stave vytvoriť
        kód TS $M_{merged}$, ktorý bude obsahovať tieto TS a pomocnú stavovú logiku, ktorá prijme ak $M_{UTS}$
        skončí.
    \item Nakoniec, sme v stave vytvoriť taký úplný TS $M\Sigma$, ktorý pred svoj vstup $<M>\#<w>$ vypíše na
        výstup kód TS <Mx>, ktorý bude obsahovať spojený TS $M_{merged}$, TS $M_copy$ a pomocné
        prechody medzi týmito TS.
    
    \item Redukcia je potom funkcia $\sigma: \{0,1,\#\}^* \to \{0,1\}^*$, ktorá je realizovaná úplnym
    TS $M\sigma$.
\end{itemize}

\subsection*{Korektnosť redukcie $\sigma$}
Skúmajme jazyk L(Mx):
\begin{enumerate}
    \item $L(Mx) = \emptyset \iff$ <M> nie je korektný kód TS alebo TS <M> na slove <w> cyklí 
    \item $L(Mx) = \Sigma^* \iff$ <M> je správne sformulovaný kód TS a TS s kódom <M> prijíma kód <w>
\end{enumerate}

Dokážeme, že redukcia je korektná.
\begin{enumerate}
    \item <M>\#<w> $\in MP \iff$ TS M je správne sformovaný a TS <M> príjme <w> $\iff L(Mx) =
        \Sigma^* \iff$ TS <Mx> taký, že jazyk L(Mx) obsahuje aspoň jeden reťazec z jazyka Affine
        $\iff$ <Mx> $\in$ TurringAffine
\end{enumerate}

Nakoniec je nutné ukázať, že pre každú kombináciu konštant $a_0$ a $a_1$ je jazyk Affine vždy
neprázdny, teda je možné nájsť aspoň jeden reťazec jazyka Affine. Ak by bol jazyk Affine prázdny,
potom by nebolo možné redukciou vyjadriť oba prípady rozhodovacieho problému MP a redukcia by teda
neexistovala. 

Avšak, pre ľubovoľné konštantny $a_0$ a $a_1$ vždy existuje reťazec, ktorý patrí do daného jazyka Affine.
Napríklad pre $w = 0^{a_1}$ vždy $w
\in Affine$, pretože platí $a_0 \times a_1 + a_1 \times 0 - a_1\times a_0 = 0$.

Dokázali sme teda, že existuje redukcia z MP, ktorý je nerozhodnuteľný, na problém TuringAffine.
TuringAffine je teda nutne nerozhodnuteľný.
\subsection*{Idea čiastočnej rozhodnuteľnosti}
Čiastočnú rozhodnuteľnosť je možné dokázať redukciou problému TuringAffine na iný rozhodovací
problém, ktorý je práve čiastočne rozhodnuteľný, napr. problém neprázdnosti jazyka TS (problém NEP). 
Problém NEP je čiastočne vyčísliteľný podľa tvrdenia zo skript, str. 129. 

Potom totiž platí vzťah $TurringAffine \leq NEP$ a podla vety $6.3.1$ (skripta, str. 128) platí, že
ak NEP je rekurzívne vyčísliteľný, potom aj TurringAffine je rekurzívne vyčísliteľný, teda čiastočne
rozhodnuteľný. 

Následne si ukážeme, akým spôsobom by bola prevedená redukcia $\sigma$.
Formálne sú rozhodovacie problémy nasledujúce:
\begin{enumerate}
    \item TuringAffine = \{<M>| jazyk TS s kódom <M> obsahuje aspoň 1 reťazec z jazyka Affine\} $\cup \{0,1\}^*$ 
    \item NEP = \{<M>| jazyk TS s kódom <M> obsahuje aspoň 1 (je neprázdny)\} $\cup \{0,1\}^*$ 
\end{enumerate}

Redukcia $\sigma: {0,1}^* \to {0,1}^*$, ktorá každej inštancii z jazyka TuringAffine priradí
inštanciu jazyka NEP, by bola realizovaná nasledujúco:
Úplný TS realizujúci redukciu $\sigma$ pre daný vstup má na svojom výstupe TS s kódom <Mx>, ktorý
realizuje nasledujúcu činnosť:
\begin{enumerate}
    \item TS Mx overí, či reťazec w na jeho vstupe patrí do jazyka Affine. Príslušnosť reťazca do
        jazyka Affine je realizovateľná pomocou TS - stačí spočítať počet symbolov 0 a 1 v reťazci
        w, previesť príslušné násobenie a odčítanie a porovnať výsledok voči nule. Konštanty
        a0 a a1 môže mať daný TS zakódované vo svojom stavovom riadení.
    \item Ak reťazec w nepatrí do jazyka Affine, potom TS Mx odmietne.
    \item Inak TS Mx posunie reťazec w, ktorý má zapísaný na páske, a skopíruje kód
        TS M <M>, čím na páske vznikne <M>\#w
    \item TS Mx overí, či TS s kódom <M> je korektne sformovaný TS. Ak nie odmietne.
    \item Napokon, TS Mx s pomocou UTS simuluje prijatie reťazca w TS s kódom <M>. Ak TS s kódom <M>
        odmietne reťazec w alebo cyklí, potom TS Mx odmietne, inak prijme.
\end{enumerate}
Skúmajme jazyk TS Mx:
\begin{enumerate}
    \item $L(Mx) = \emptyset \iff$ TS <M> nie je správne sformovaný alebo TS <M> je správne
        sformovaný, ale L(M) neobsahuje ani jeden reťazec z jazyka Affine.
    \item $L(Mx) \neq \emptyset \iff$ TS <M> je správne sformovaný a L(M) obsahuje aspoň jeden reťazec
        z jazyka Affine
\end{enumerate}

Zjavne platí, že TS <M> obsahuje reťazec z jazyka Affine $\iff$ TS <M> je správne sformovaný a L(M)
obsahuje aspoň jeden reťazec z jazyka Affine $\iff L(Mx) \neq \emptyset \iff$ TS s kódom <Mx> a
jazyk L(Mx) je neprázdny.

\section*{Úloha č.4}
Turingovú úplnosť programu \textit{RacionalC} dokážeme konštruktívne. Ukážeme, že každý TS je možné
zakódovať ako ekvivalentný program \textit{RacionalC}, a naopak, že každý program \textit{RacionalC}
je možné vytvoriť ekvivalentný TS.

Pred popisom jednotlivých prevodov je nutné uvedomiť si, akým spôsobom sú si TS a
\textit{RacionalC} podobné. \textit{RacionalC} pracuje s racionálnym číslom, pričom umožňuje toto číslo deliť a násobiť 2,
prípadne nastavovať jeho párnosť, či nepárnosť, a rovnako disponuje príkazmi pre zmenu toku programu
podľa párnosti. 
Efekt týchto operácii môžeme skúmať na binárnom kóde racionálneho čísla v registri x.
Zjavne platí, že operácie deleno / násobenie 2 posúvajú desatinnú čiarku v binárnej reprezentácii
čísla. Podobne operácia even / odd v skutočnosti len mení hodnotu bitu čísla x, ktorý leží tesne
pred desatinnou čiarkou. Nakoniec, príkaz if modulo v skutočnosti zisťuje aktuálnu hodnotu bitu
pred desatinnou čiarkou a podľa toho skáče v programe.

Ekvivalentné operácie ku spomenutým operáciam môžeme vidieť aj v TS. Uvažujme pásku automatu len nad
symbolmi 0 a 1. Potom pozíciu čítacej hlavy na páske
môžeme vnímať ako pozíciu desatinnej čiarky v čísle s kódom odpovedajúcemu páske.
Operácie násobenie a delenie je možné realizovať v TS ako posun čítajúcej hlavy.
Podobne, zápis symbolu pod čtecí hlavou je možné sémanticky vnímať ako operácie odd/even.
Nakoniec, samotné prechody TS realizujú podmienené vykonávanie v závislosti na hodnote symbolu pod
čtecí hlavou na páske.

Jednotlivé operácie je teda možné zakódovať ekvivalentne v TS aj v programe \textit{RacionalC}.

V následujúcej časti predstavený príkladný spôsob zakódovania spolu s ošetrením špeciálneho
chovania, akým je prepadnutie hlavy TS, či nekonečné rozširovanie reprezentácie racionálneho čísla
do oboch smerov v programe \textit{RacionalC}.

\subsection*{A - Prevod TS na RationalC}
Podľa zadania prevádzame deterministický TS s abecedou $\Sigma = {0,1}$ a páskovou abecedou 
$\Gamma = \Sigma \cup {\Delta}$. V prípade, že by pásková abeceda obsahovala ďalšie znaky, je možné 
TS previesť na TS s $\Gamma = \Sigma \cup {\Delta}$ pomocou zakódovania symbolov rozšírenej páskovej abecedy
ako postupností symbolov z $\Gamma$ (opora, str. TODO).

Prevod TS na RationalC sa skladá z nasledujúcich částí
\subsection*{Prevod vstupnej pásky TS na číslo $x_0$}
    Vstupná páska TS má tvar $\Delta w \Delta$, kde $w \in \Sigma$. Keďže vieme, že program
    $RacionalC$ má na vstupe celé číslo $x_0$ a naopak TS začína na pozícii $\Delta$, musíme
    pred prevodom reťazec $\Delta w \Delta$ reverzovať. 
    Následne je páska $\delta w^R \delta$ obsahujúca znaky $0,1,\Delta$ je prevedená nasledujúco:
    \begin{enumerate}
        \item 0 je vyjadrená ako 10
        \item 1 je vyjadrená ako 11
        \item $\Delta$ je vyjadrená ako 00
        \item $\!$ je vyjadrená ako 11
    \end{enumerate}
    Kódovanie sme rozšírili o špeciálny symbol $\!$, ktorý nie je súčasťou páskovej abecedy.
    Tento špeciálny symbol je nutný pre korektné dekovanie stavu, kedy TS prepadla hlava.

    Po prevedení symbolov w na takéto binárne kódovanie je výsledný reťazec interpretovaný ako
    binárne zakódované prirodzené číslo rozšírené o kód symbolu $!$.

    Príklad w: $\Delta011\Delta$ sa po reverzácii na $\Delta110\Delta$ zobrazí na $00 11 10 10 00
    11$, teda na prirodzené číslo $931$. Vďaka kódu $00$ pre $\Delta$ obsahuje racionálne číslo nekonečno znakov
    reprezentujúcich $\Delta$ z prava aj z ľava pôvodonej pásky $w$, pretože dvojica 00 pridaná
    pred aj na koniec binárnej reprezentácie čísla nemení jeho význam.

    Nakoľko sme oproti reprezentácii pásky TS posunuli desatinnú čiarku pridaním oddelovača $!$, je
    nutné na začiatku programu \textit{RacionalC} vykonať 2x príkaz $x \\= 2;$ aby sme posunuli čiarku na
    správne miesto.

\begin{enumerate}
    \item Prevod jednotlivých pravidiel TS na príkazy jazyka \textit{RacionalC}
        Jednotlivé stavy TS sú v \textit{RationalC} reprezentované sekvenciou príkazov. 
        Keďže jednotlivé symboly TS sú v RationalC reprezentované dvojicami bitov racionálneho čísla, potom posun hlavy je
        realizovaný 2x násobením alebo 2x delením, čo má za následok posun desatinnej čiarky o
        dvojicu bitov.
        Pre každý prechod $p$ TS zo stavu q je vygenerovaný príkaz nasledujúco:
\end{enumerate}
        \begin{verbatim}
        q: x /= 2   
        q+1 if x \% 2 == 0 goto q-6 
        q+2 x *= 2
        q+3 if x \% 2 == 0 goto q-0 
        q+4 if x \% 2 == 1 goto q-1 
        q+5 return B;
        q+6 x *= 2
        q+7 if x \% 2 == 0 goto q-delta
        q+8 if x \% 2 == 1 goto q-delta
        \end{verbatim}
        Hodnota $B$ riadku $q+5$ je 0 pre nekoncový stav a $1$ pre $q_f$.
        V prípade, že stav $q$ neobsahuje prechod pre daný symbol z $\Gamma$, je daný riadok
        nahradený prázdnym riadkom (pre $\Delta$ riadok $q+1$, pre $0$ $q+3$, pre $1$ $q+4$.

        Povšimnime si, že ak stav nie je koncový a zároveň neobsahuje v TS žiaden prechod, RationalC
        skončí program s návratovou hodnotou 0, čo je ekvivalentné abnormálnemu zastaveniu TS na
        nedefinovanom prechode.

        Symboly $q-delta, q-0, q-1$ tvaru $Q-\Gamma$ predsavujú symbolický vyjadrenie čísla riadku, ktorý
        reprezentuje sekvenciu príkazov vykonávajúci konkrétny prechod.
        Napríklad prechodu $\delta(q, 0) = (p, L)$ zodpovedá sekvencia na adrese $q-0$:
        \begin{verbatim}
        q-0: x /=2
        x /=2
        if \% 2 == 0 goto p
        if \% 2 == 1 goto p
        \end{verbatim}
        Pre prechod R získame sekvenciu analogicky, nahradením x /=2 za x *=2.
        Pri zápise symbolu z abecedy $\Gamma$ nahradíme dvojicu násobení / delení nasledujúcou
        sekvenciou:
        \begin{enumerate}
            \item Zápis $\Delta$ ako 00: x = even(x); x /= 2; x = even(x); x */ 2;
            \item Zápis $0$ ako 10: x = even(x); x /= 2; x = odd(x); x */ 2;
            \item Zápis $0$ ako 11: x = odd(x); x /= 2; x = odd(x); x */ 2;
        \end{enumerate}
        Príkazy $odd()$ a $even()$ pracujú s bitom racionálneho čísla pred desatinnou čiarkou, teda
        umožňujú simulovať zápis znaku na dvojici bitov, ktorá je pred desatinnou čiarkou, teda
        odpovedá pôvodnemu symbolu pod hlavou v TS.

        Ošetrenie prepadnutia hlavy:
        Racionálne číslo obsahuje špeciálnu dvojicu bitov 01 na začiatku reťazca (na najvyžšich
        pozíciach). Na začiatku sekvencie zodpovedajúcej vykonániu stavu $q \in Q$ pribudne
        sekvencia, ktorá skontroluje, či sa aktuálna dvojica bitov pred desatinnou čiarkou nerovná
        špeciálnemu symbolu reprezentujúcemu prepadnutie hlavy. Ak áno, potom program končí hodnotou
        0. Inak pokračuje vykonávanie stavu.


\subsection*{B - RationalC na TS}
Racionálne číslo $x_0$ môžeme reprezentovať ako binárne kódovaný číslo. Na počiatku má teda páska
tvar $\Delta w \Delta$, kde w je binárne zakódované racionálne číslo a zároveň obsahuje TS sekvenciu
prechodov do prava, ktoré posunú hlavu na tú pozíciu, ktorá v pôvodnom racionálnom čísle
predstavovala desatinnú čiarku. Desatinná čiarka simulovaného registra $x_0$ sa v TS nachádza vždy
za pozíciou hlavy.
Prechod TS s posunutím hlavy doprava realizuje príkaz $x *= 2$, doľava zas $x /= 2$. Príkaz odd /
even sú realizované ako zápis symbolu 1 / 0 pod hlavou.
Každý riadok s príkazom programu RationalC je realizovaný ako jeden unikátny stav v TS.
Príkazy $x *= 2 / x /= 2$ sú prechody z aktuálneho stavu do stavu a posunutím hlavy,
príkazy even() či odd() zas zápisom symbolu pod hlavou na páske TS.
Príkaz return 1; predstavuje prechod pod ľubovoľným symbolom $\Sigma$ do koncového stavu TS,
príkaz return 0 zas spustenie podprogramu, ktorý bude nekonečne cykliť do prava.
Pre všetky stavy je pod symbolom $\Delta$ pridaný podprogram, ktorý skočí na prvý $\Delta$ na pravo od
hlavy, vyvolá shift right, skočí na prvý delta na ľavo a zapíše do neho symbol 0.
Týmto spôsobom je ošetrená situácia, kedy sa racionálne číslo delením rozšíruje smerom do ľava
(nulami), čo by spôsobilo prepadnutie hlavy v TS. 
Tak isto, pri násobení čísla tento podprogram korektne ošetrí rozšírenie binárneho kódovania o 0
zprava.

\end{document}
